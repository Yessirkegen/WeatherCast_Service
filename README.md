# WeatherService
Part of WeatherTracker microservices structure

Вот обзор использованных в проекте дизайн-паттернов и их расположение в файлах:

### 1. **Singleton**
- **Файл:** `config/config.go`
- **Описание:** Паттерн обеспечивает создание только одного экземпляра класса конфигурации. Используется для загрузки конфигурационных параметров из файла `.env` с помощью `sync.Once`.

### 2. **Factory**
- **Файл:** `weatherapi/weather_client.go`
- **Описание:** Паттерн реализован в функции `NewWeatherClient`, которая создает и настраивает экземпляр `weatherClient`. Этот паттерн используется для создания объектов без указания конкретного класса.

### 3. **Dependency Injection**
- **Файлы:** 
  - `handlers/weather_handler.go`
  - `services/weather_service.go`
- **Описание:** Зависимости (например, `WeatherService` и `WeatherClient`) передаются в обработчики и сервисы через конструкторы, что упрощает тестирование и замену реализаций.

### 4. **Repository**
- **Файл:** `pkg/cache/cache.go`
- **Описание:** Паттерн позволяет абстрагировать доступ к данным. В данном случае используется для кеширования данных о погоде, что позволяет скрыть детали реализации хранения данных.

### 5. **Adapter**
- **Файл:** `weatherapi/weather_client.go`
- **Описание:** Паттерн адаптирует интерфейс HTTP API OpenWeather к интерфейсу `WeatherClient`, который используется в приложении. Это позволяет изменять реализацию API без изменения логики приложения.

### 6. **Command**
- **Файлы:** 
  - `cmd/weather/main.go`
  - `handlers/weather_handler.go`
- **Описание:** Паттерн реализуется при обработке HTTP-запросов. Каждое действие (например, получение погоды) инкапсулируется в отдельном методе.

### 7. **Observer (на уровне приложения)**
- **Файл:** (неявно)
- **Описание:** Если в будущем вы добавите функциональность, чтобы пользователи могли подписываться на уведомления о погоде, это будет реализация паттерна "Наблюдатель". Обработчик уведомлений будет "наблюдать" за изменениями состояния погоды и информировать подписчиков.

Каждый из этих паттернов способствует улучшению структуры кода, облегчает тестирование и поддержку, а также улучшает масштабируемость приложения.